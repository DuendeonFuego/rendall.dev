---
title: 'Class notes: Mastering Git'
date: 2019-01-26
layout: layouts/post.njk
category: tech
tags:
    - code
    - git
---

I recently took up the [Microsoft Dev Collective](https://developer.microsoft.com/en-us/collective)'s offer for a 30-day free trial of [Pluralsight](https://www.pluralsight.com/) and, among other courses, I took [Paolo Perrotta](https://twitter.com/nusco)'s excellent video course *[Mastering Git](https://app.pluralsight.com/library/courses/mastering-git)* comprising 8 videos of 2 hours 45 minutes total. I highly recommend it if you are even a little unclear on how git works. Especially if, like me, you use the same git commands every day with only a vague notion of what they do.

These are my class notes:

git has 4 areas:

- working area - project directory on file structure
- index - aka the staging area
- repository
- stash

2 questions which will completely define and explain any command:

- How does this command move information across the 4 areas?
- How does this command change the repository?

Some useful git log commands:

- git log --graph --decorate --oneline
- git help log
- git log --patch

Distributed Workflow patterns:

- Distribution models (many)
    - Peer-to-peer
    - Centralized
    - Pull-request model
    - hierarchical model
    - etc.
- Branching models
    - Stable and unstable branch (does a branch allow broken code?)
    - Integration branch ("Master" branch to which all repos merge/rebase)
    - Release branch
    - Feature branch
    - Hotfix branch (versus cherry-pick, which is a rebase)
- Constraints
    - Merge versus rebase
    - Which developers can do what to which branches?
    - Don't push when the build is broken (CI error)
    - History refactoring before push to integration?
    - Every pull request linked to an issue/ticket number

Gitflow:

- is not optimal for every kind of project. Don't "just use Gitflow".
- web apps that need to maintain only one release branch
- project with continuous integration in which features released immediately, Gitflow has too many layers
- projects with long feature development with huge code bases could cause issues, perhaps better to integrate when features are not yet complete to avoid merge issues

Growing a workflow:

- Avoid designing a complete workflow from the beginning, but start small and grow it.
- Sample starter workflow:
    - Distribution model: Centralized
    - Branching model:
    *     One integration branch (master)
    -     One feature branch per feature
      Constraints:
        Keep master stable, fix ASAP if it breaks
        Integrate feature branches every few days
        User merge over rebase by default

  "Simple, clear purpose and principles give rise to complex intelligent behavior. Complex rules and regulations give rise to simple stupid behavior."

  -- Dee Hock

Personal thoughts:
  Other constraints I have seen:
    Merge feature branches into the master branch, but clean up with interactive rebase the history of the branch before doing so.
    Do not rebase the history of the master branch.
    Features that are not released yet should be hidden by default, to be turned on with an internal flag
    Branches should have an associated issue number, and commit messages should reference that number (required a githook to enforce)
    
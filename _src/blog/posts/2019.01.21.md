---
title: 'RxJS does not behave like Promise'
subtitle: 'Put that in your `pipe` and smoke it'
date: 2019-01-21
layout: layouts/post.njk
category: tech
tags:
    - code
    - typescript
    - RxJS
---

## Problem

You like how `Promise` works. Intuitive and easy to follow. 

You also like [`RxJS`](https://rxjs.dev/guide/overview). Not so easy to follow.  

`RxJS` centers on the metaphor of streams: streams of events, streams of data, streams of user input, streams of arbitrary data. You can define at declaration the entire flow of input and outputs by combining, splitting, modifying or skipping stream items.

## Discussion

Consider the following `Promise` chain. `requestInfo` takes a file location and returns the file, perhaps asynchronously. See if you can guess from the `then` arguments what happens next:

```typescript
requestInfoFrom(location)
    .then((response) => isStatusOk(response)?
        extractContent(response) : throwError("bad request, no biscuit"))
    .then((content) => extractData(content))
    .then(data => transformData(data))
    .then((log) => logIt(log))
    .then(() => etc())
    .catch((error) => notifyUI(error));
```

It appears that information is requested, `then` the response status is checked and, if ok, `then` data is extracted from the response, `then` transformed, `then` logged, and so on. If there is an error, the UI will handle it. Promise chains like this enable devs to write descriptively about what is happening. If the dev felt it necessary, she could even abstract the Promise chain into: `requestInfo(location).then(checkStatus).then(extractData).then(transformData)...`

Consider the code below. It is an attempt to write an `RxJS` stream with the same descriptive clarity as the `Promise` chain:

```typescript
const infoFlow$:Observable<string> = Observable.create(getInfoFrom(location));

infoFlow$
  .pipe( flatMap((response) => isStatusOk(response)?
      extractContent(response) : throwError("bad status, no biscuit")),
    map((content) => extractData(content)),
    tap(data => transformData(data)),
    tap((log) => logIt(log)),
    shareReplay(() => etc()),
    catchError(error) => notifyUI(error)
    );
```

It also to my mind is just not *magic* enough. I would like to be able to abstract away certain details from this flow. `flatMap`,`shareReplay`, `tap` are not always very compelling, nor truly *descriptive* of the intent. I would like a bit more poetic description of what's happening there. Not to say that I *always* want to have magic, but it's nice to be *able* to.

Here is a line from my ongoing [Open Source Inventory Entry](https://github.com/rendall/osie) project:

```javascript
recordClick$
  .pipe(
    recorderHandler,
    audioPlayerHandler,
    blobToBase64,
    speechToTextHander)
  .subscribe(x => console.log("dataresult:", x))`
```

This stream waits for a user 'click' on the recorder button (the `recordClick$` observer), and then passes the event along to `recordHandler` which toggles on the user's microphone until the next toggle click. It then passes the microphone recording to `audioPlayerHandler`, which creates and populates an `<audio>` element in the webpage so the user can hear their recording. It also immediately passes the sound data to `blobToBase64` which converts the raw data into a base64 string, which in turn sends that along to `speechToTextHandler`. This operator then sends a request to, and awaits the response from, a speech-to-text service. Then finally, `subscribe` logs the result to console.

 (*There are some valid criticisms to be leveled at the code above: it is not clear at a glance what these pipe elements accept nor what they emit, nor even what they _are_; it's not clear what sort of operators are involved. How does the flow change? Is there a split or a conditional or a filter? Are there side effects? The line above, as it stands, does not answer these questions. In short, it is _magic_. This can be addressed with a bit of deconstruction, as described below.*)

How do we get a more easy-on-the-eyes kind of flow into our code, like the `.then`s in `Promise`s but without breaking the idioms or intent of RxJS?

## Solution

First and foremost, and it bears repeating, `Observable`s are just functions that do not run until they are `subscribe`d to, unlike `Promise`s which run immediately. This is the `RxJS` equivalent of tech support asking if your computer is plugged in: nothing else will work if that is not covered, but it almost feels patronizing to mention, since it's so fundamental. Properly, somewhere in the code there needs to be some version of this line: `infoFlow$.subscribe()` 'Nuff said.

Here is how you can get RxJS to behave more like Promise without *breaking* the RxJS way (*Just to set expectations, we are talking about `RxJS 6` and if you're using another version, modify accordingly. Also, examples are in `Typescript` but do not fear the `Typescript`! Just remove all that type stuff and boom! you have `javascript`. Also, I appended the javascript compilation at the end of the post.*):

Whatever element goes into `pipe` (such as `blobToBase64`) needs to be an `Operator` which by definition takes an `Observable` and outputs another `Observable`. It needs to have this type signature:

```typescript
(observable: Observable<T>) => Observable<U>
```

Not to belabor the point, but in `flow$.pipe(pipeOperator)`, for example, `pipeOperator` takes an `Observable` and returns an `Observable`.

So, here is how you do that:

```typescript
const pipeOperator = (observable: Observable<T>) => observable.lift(liftOperator);
```

`lift` takes an `Operator` as a parameter and applies that operator to `observable`, returning a new `Observable`. We are still sticking to the signature, of taking an `Observable` and returning an `Observable`.

Let's unpack `liftOperator`:

```typescript
const liftOperator = {
    call(subscription, observable) {
        observable.subscribe(new SomeSubscriberClass(subscription))
        }
    }
```


```typescript
// where SomeSubscriberClass has this structure:

class SomeSubscriberClass extends Subscriber<U> {

    constructor(subscriber:Subscriber<T>) {
        super(subscriber);
    }

    _next(value:<T>):void {
    }

    _complete(): void {
    }

    _error(err:Error):void {
    }
}
```

 (*Before we go on, credit where credit is due, and to teach a programmer to fish: I learned a lot about RxJS 6, particularly this `lift` trick, from John Lindquist's course [Build Your Own RxJS Pipeable Operators](https://egghead.io/courses/build-your-own-rxjs-pipeable-operators) on [egghead.io](https://egghead.io). One might almost say I _lifted_ this trick. I highly recommended the course.*)